# Synchronizing

Синхронизация доступа к данным
Synchronizing Data Access

Напомним, что безопасность потоков - это свойство объекта, которое гарантирует безопасное выполнение несколькими потоками одновременно.
Теперь, когда у нас есть несколько потоков, способных обращаться к одним и тем же объектам в памяти, мы должны убедиться, что наш доступ к этим данным организован так,
что мы не можем получить недопустимые или неожиданные результаты. Поскольку потоки работают в общей среде и пространстве памяти, как мы можем предотвратить взаимодействие
двух потоков друг с другом? 

1) Понимание стоимости синхронизации

Мы завершим этот раздел, отметив, что синхронизация, хотя и полезна, на практике может быть дорогостоящей. В то время как многопоточное программирование
подразумевает выполнение нескольких задач одновременно, синхронизация подразумевает получение нескольких потоков и обеспечение их выполнения более однопоточным способом.
Например, предположим, что у нас есть класс с высокой степенью параллелизма, с многочисленными методами, которые синхронизируются с одним и тем же объектом.
Допустим, 50 одновременных потоков обращаются к нему. Скажем также, что в среднем каждому потоку требуется скромные 100 миллисекунд.
В этом примере, если все потоки пытаются получить доступ к монитору одновременно, сколько времени потребуется им для завершения своей работы, если предположить,
что в пуле потоков доступно 50 потоков?

50 threads x 100 milliseconds
   = 5,000 milliseconds 
  = 5 seconds
Несмотря на то, что пять секунд могут показаться не слишком большими, на самом деле компьютерное время довольно длинное. Что, если до истечения пяти 
секунд будет создано 50 новых задач? Это будет накладываться на рабочую нагрузку, в результате чего большинство потоков будут постоянно переходить
в состояние ожидания или «зависания». В приложении это может привести к тому, что задачи, которые обычно быстро выполняются в несинхронизированной среде, 
занимают значительно больше времени.
Синхронизация - это защита целостности данных за счет производительности. Во многих случаях затраты на производительность минимальны,
но в крайних случаях приложение можетзначительно замедлиться из-за включения синхронизации. Возможность выявлять проблемы синхронизации,
в том числе находить способы повышения производительности в синхронизированных многопоточных средах, является ценным навыком на практике. 

2) Представьте себе, что в нашем зоопарке есть программа для подсчета овец, желательно такая, которая не усыпляет работников зоопарка! 
Каждый работник зоопарка выбегает в поле, добавляет новую овцу в стадо, подсчитывает общее количество овец и бежит к нам, чтобы сообщить результаты.
Мы представляем следующий код, чтобы представить это концептуально:


import java.util.concurrent.*;
public class SheepManager {
   private int sheepCount = 0; 
  private void incrementAndReport() {  
    System.out.print((++sheepCount)+" ");  
 }  
 public static void main(String[] args) {    
  ExecutorService service = null;  
    try {    
     service = Executors.newFixedThreadPool(20);  
       SheepManager manager = new SheepManager();   
      for(int i=0; i<10; i++)   
         service.submit(() -> manager.incrementAndReport());  
    } finally {      
   if(service != null) service.shutdown();  
   }   
}}
Обратите внимание, что мы используем ++оператор предварительного увеличения для обновления sheepCountпеременной. Помните,
что оператор предварительного увеличения является сокращением для следующего выражения, в котором возвращается вновь присвоенное значение:
sheepCount = sheepCount + 1;
Проблема возникает, когда два потока выполняют правую часть выражения, считывая «старое» значение, прежде чем любой из потоков записывает «новое» значение переменной.
Два назначения становятся излишними; они оба присваивают одно и то же новое значение, причем один поток перезаписывает результаты другого. Рисунок 7.3
демонстрирует эту проблему с двумя потоками, предполагая, что sheepCountимеет начальное значение 1.
Рисунок 7.3. Отсутствие синхронизации потоков.
На рисунке 7.3 видно, что оба потока читают и записывают одинаковые значения, что приводит ++sheepCountк потере одной из двух операций.
Следовательно, оператор приращения ++не является потокобезопасным. Как вы увидите позже в этой главе, неожиданный результат двух задач, выполняемых одновременно,
называется состоянием гонки .
Возвращаясь к нашему SheepManagerприложению, мы выбираем большой размер потока, 20чтобы все задачи могли выполняться одновременно.
Допустим, что каждое лямбда-выражение, переданное исполнителю потока, соответствует работнику зоопарка. Каждый раз, когда работник зоопарка увеличивает счетчик овец,
они бегут назад, чтобы сообщить результаты. Что вы ожидаете от этой программы? Хотя выходные данные будут отличаться, ниже приведены некоторые примеры,
созданные этой программой:
1 2 2 3 4 5 6 7 8 9
2 4 5 6 7 8 1 9 10 3
2 1 3 4 5 6 7 8 9 10
В этом примере несколько работников совместно используют sheepCountпеременную. В первом примере два сотрудника зоопарка звонят ++sheepCountодновременно,
в результате чего фактически теряется одна из операций приращения с последним общим значением 9вместо 10. вВ других примерах результаты из более ранних
потоков выводятся до тех, которые начались позже, например 3, выводятся после 4во втором примере. Мы знаем, что у нас были 10рабочие, но результаты неполные и не в порядке.
Идея заключается в том, что некоторые работники зоопарка могут бежать быстрее на пути к полю, но медленнее возвращаться назад и опаздывать.
Другие могут добраться до поля последними, но как-то первыми вернутся, чтобы сообщить о результатах.

3)Защита данных с помощью атомарных классов

С выпуском ConcurrencyAPI Java добавила новый java.util.concurrent.atomicпакет, чтобы помочь координировать доступ к примитивным значениям и ссылкам на объекты.
Как и в большинстве классов ConcurrencyAPI, эти классы добавлены исключительно для удобства.
В нашем первом SheepManagerпримере вывода одно и то же значение 2было напечатано дважды, причем самый высокий счетчик был 9вместо 10. Как мы продемонстрировали
в предыдущем разделе, оператор приращения ++не является потокобезопасным. Кроме того, причина, по которой он не является поточно-ориентированным, заключается в том,
что операция не является атомарной, выполняя две задачи: чтение и запись, которые могут быть прерваны другими потоками.
Atomicявляется свойством операции, которая должна выполняться как единая единица выполнения без какого-либо вмешательства другого потока. Потоково-безопасной
атомарной версией оператора приращения будет та, которая выполняет чтение и запись переменной как одну операцию, не позволяя другим потокам обращаться к
переменной во время операции. На рисунке 7.4 показан результат превращения sheepCountпеременной в атомарный.
Рисунок 7.4 Синхронизация потоков с использованием атомарных операций
Рисунок 7.4 напоминает наш предыдущий рисунок 7.3 , за исключением того, что чтение и запись данных являются атомарными по отношению к sheepCountпеременной. 
Любой поток, пытающийся получить доступ к sheepCountпеременной во время атомарной операции, должен будет ждать, пока атомарная операция с переменной завершится.
Конечно, эта исключительность применяется только к потокам, пытающимся получить доступ к sheepCountпеременной, при этом оставшаяся часть памяти не затронута этой операцией.
Поскольку доступ к примитивам и ссылкам в Java распространен в общих средах, ConcurrencyAPI включает в себя множество полезных классов, которые концептуально 
совпадают с нашимипримитивные классы, но которые поддерживают атомарные операции. В таблице 7.7 перечислены атомарные классы, с которыми вы должны быть знакомы для экзамена.


Таблица 7.7 Атомные классы
Class Name	                           Описание
AtomicBoolean                     	booleanЗначение , которое может быть обновлен атомарно
AtomicInteger                  	intЗначение , которое может быть обновлен атомарно
AtomicIntegerArray	                     intМассив , в котором элементы могут быть обновлены атомарно
AtomicLong                              	longЗначение , которое может быть обновлен атомарно
AtomicLongArray	                        longМассив , в котором элементы могут быть обновлены атомарно
AtomicReference                  	Общая ссылка на объект, которая может быть обновлена атомарно
AtomicReferenceArray                            	Массив общих ссылок на объекты, в которых элементы могут обновляться атомарно

Как мы используем атомарный класс? Каждый класс включает в себя множество методов, которые эквивалентны многим из встроенных примитивных операторов,
которые мы используем в примитивах, таких как оператор присваивания и операторы =приращения ++. Мы описываем общие атомные методы, которые вы должны 
знать для экзамена в таблице 7.8 .

Таблица 7.8. Обычные атомарные методы
Class Name                                                            	Описание
get()	                                               Получить текущее значение
set()                                      	Установить заданное значение, эквивалентное =оператору присваивания
getAndSet()                                	Атомно устанавливает новое значение и возвращает старое значение
incrementAndGet()    	Для числовых классов атомарная операция предварительного приращения эквивалентна ++value
getAndIncrement()	                 Для числовых классов атомарная операция после приращения эквивалентна value++
decrementAndGet()	                    Для числовых классов атомарная операция перед декрементом эквивалентна --value
getAndDecrement()                  	Для числовых классов атомарная операция после декремента эквивалентна value--

В следующем примере мы обновляем наш SheepManagerкласс с помощью AtomicInteger:


private AtomicInteger sheepCount = new AtomicInteger(0);
   private void incrementAndReport() {   
   System.out.print(sheepCount.incrementAndGet()+" "); 
  }
  
  
Чем эта реализация отличается от наших предыдущих примеров? Когда мы запускаем эту модификацию, мы получаем различные выходные данные, например:

2 3 1 4 5 6 7 8 9 10 
1 4 3 2 5 6 7 8 9 10
1 4 3 5 6 2 7 8 10 9
В отличие от нашего предыдущего примера вывода, числа 1через 10всегда будут выводиться. Как вы могли заметить, результаты все еще не упорядочены,
хотя мы скоро к этому вернемся. Ключевым моментом здесь является то, что использование атомарных классов гарантирует, что данные согласованы между
работниками и что никакие значения не будут потеряны из-за одновременных изменений.  

4)Улучшение доступа с помощью синхронизированных блоков

Как мы можем улучшить результаты, чтобы каждый работник мог увеличивать и сообщать результаты по порядку? Наиболее распространенным методом является
использование монитора, также называемого блокировкой , для синхронизации доступа. A monitor- это структура, которая поддерживает взаимное исключение или свойство,
которое не более одного потока выполняет определенный сегмент кода в данный момент времени.
В Java любой Objectможет использоваться как монитор вместе с synchronizedключевым словом, как показано в следующем примере:

SheepManager manager = new SheepManager();
synchronized(manager) { 
  // Work to be completed by one thread at a time
}
Этот пример называется синхронизированным блоком . Каждый поступающий поток сначала проверяет, есть ли какие-либо потоки в блоке.
Таким образом, поток «получает блокировку» для монитора. Если блокировка доступна, один блок войдет в блок, получая блокировку и предотвращая проникновение
всех остальных потоков. Пока первый поток выполняет блок, все поступающие потоки будут пытаться получить такую же блокировку и ждать завершения первого потока.
Как только поток завершает выполнение блока, он снимает блокировку, позволяя одному из ожидающих потоков продолжить работу.  
   Для синхронизации доступа между несколькими потоками каждый поток должен иметь доступ к одному и тому же Object. Например, синхронизация на разных объектах
   фактически не организовывает результаты.
Давайте SheepManagerвернемся к нашему примеру и посмотрим, сможем ли мы улучшить результаты, чтобы каждый работник увеличивал и выводил счетчик по порядку.
Допустим, мы заменили наш for()цикл следующей реализацией:

for(int i=0; i<10; i++) {  
       synchronized(manager) { 
           service.submit(() -> manager.incrementAndReport());    
     }    
  }
Это решение решает проблему? Нет! Можете ли вы определить проблему? Мы синхронизировали создание потоков, но не выполнение потоков.
В этом примере каждый поток будет создаваться по одному, но все они могут по-прежнему выполняться и выполнять свою работу в одно и то же время,
что приводит к тому же типу вывода, который вы видели ранее. Диагностика и решение проблем с многопоточностью часто является одной из самых сложных задач в
любом языке программирования.
Сейчас мы представляем исправленную версию SheepManagerкласса, которая действительно заказывает рабочих:


import java.util.concurrent.*;
public class SheepManager {
   private int sheepCount = 0;  
 private void incrementAndReport() {    
  synchronized(this) { 
        System.out.print((++sheepCount)+" ");    
  }  
 } 
  public static void main(String[] args) {   
   ExecutorService service = null;   
   try {     
    service = Executors.newFixedThreadPool(20);  
       SheepManager manager = new SheepManager();    
     for(int i=0; i<10; i++)        
    service.submit(() -> manager.incrementAndReport());    
  } finally {  
       if(service != null) service.shutdown();     
 }   
}}


Когда этот код выполняется, он будет последовательно выводить следующее:
1 2 3 4 5 6 7 8 9 10

Хотя все потоки по-прежнему создаются и выполняются одновременно, каждый из них ждет в synchronizedблоке, чтобы рабочий увеличил его и сообщил результат перед вводом. 
Таким образом, каждый работник зоопарка ждет возвращения предыдущего работника зоопарка, прежде чем выбежать на поле. Несмотря на то, что случайным образом, 
какой сотрудник зоопарка выбежит дальше, гарантировано, что на поле будет максимум один.
Мы могли синхронизироваться на любом объекте, если это был один и тот же объект. Например, следующий фрагмент кода также работал бы:

private final Object lock = new Object(); 
  private void incrementAndReport() {  
    synchronized(lock) {     
    System.out.print((++sheepCount)+" ");  
    }  
 }
Хотя нам не нужно было создавать lockпеременную final, это гарантирует, что она не будет переназначена после того, как потоки начнут ее использовать.   
  В synchronizedэтом примере мы могли бы использовать переменную атомного счета вместе с блоком, хотя это и не нужно. Поскольку synchronizedблоки
  допускают доступ только к одному потоку, мы не получим никакого улучшения, используя атомарную переменную, если единственный раз, когда мы обращаемся к переменной,
  находится внутри synchronizedблока.
  
  
5) Методы синхронизации

В предыдущем примере мы установили наш монитор, используя synchronized(this)тело метода. Java на самом деле обеспечивает более удобное улучшение компилятора для этого. 
Мы можем добавить synchronizedмодификатор к любому методу экземпляра для автоматической синхронизации самого объекта. Например, следующие два определения метода эквивалентны:

private void incrementAndReport() {
      synchronized(this) {   
      System.out.print((++sheepCount)+" ");
      } 
  } 
  private synchronized void incrementAndReport() {  
    System.out.print((++sheepCount)+" "); 
  }
Первый использует synchronizedблок, тогда как второй использует synchronizedмодификатор метода. То, что вы используете, полностью зависит от вас.
Мы также можем добавить synchronizedмодификатор к staticметодам. Какой объект используется в качестве монитора, когда мы синхронизируемся по staticметоду?
Объект класса, конечно! Например, следующие два метода эквивалентны для staticсинхронизации внутри нашего SheepManagerкласса:

public static void printDaysWork() { 
     synchronized(SheepManager.class) { 
        System.out.print("Finished work");     
 } 
  }  
 public static synchronized void printDaysWork() {   
   System.out.print("Finished work");  
 }
Как и прежде, первый использует synchronizedблок, а второй пример использует synchronizedмодификатор. Вы можете использовать staticсинхронизацию,
если вам нужно упорядочить доступ к потокам для всех экземпляров, а не для одного экземпляра.  

Понимание стоимости синхронизации

Мы завершим этот раздел, отметив, что синхронизация, хотя и полезна, на практике может быть дорогостоящей. В то время как многопоточное программирование
подразумевает выполнение нескольких задач одновременно, синхронизация подразумевает получение нескольких потоков и обеспечение их выполнения более однопоточным способом.
Например, предположим, что у нас есть класс с высокой степенью параллелизма, с многочисленными методами, которые синхронизируются с одним и тем же объектом.
Допустим, 50 одновременных потоков обращаются к нему. Скажем также, что в среднем каждому потоку требуется скромные 100 миллисекунд.
В этом примере, если все потоки пытаются получить доступ к монитору одновременно, сколько времени потребуется им для завершения своей работы, если предположить,
что в пуле потоков доступно 50 потоков?

50 threads x 100 milliseconds
   = 5,000 milliseconds 
  = 5 seconds
Несмотря на то, что пять секунд могут показаться не слишком большими, на самом деле компьютерное время довольно длинное. Что, если до истечения пяти 
секунд будет создано 50 новых задач? Это будет накладываться на рабочую нагрузку, в результате чего большинство потоков будут постоянно переходить
в состояние ожидания или «зависания». В приложении это может привести к тому, что задачи, которые обычно быстро выполняются в несинхронизированной среде, 
занимают значительно больше времени.
Синхронизация - это защита целостности данных за счет производительности. Во многих случаях затраты на производительность минимальны,
но в крайних случаях приложение можетзначительно замедлиться из-за включения синхронизации. Возможность выявлять проблемы синхронизации,
в том числе находить способы повышения производительности в синхронизированных многопоточных средах, является ценным навыком на практике. 


Использование параллельных коллекций
Using Concurrent Collections
